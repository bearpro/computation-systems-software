#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[{"name":"csharp"},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!fsharp

#load @"./lib/Signal.fs"
#r "nuget: Plotly.NET.Interactive"
#r "nuget: FSharp.Charting"

open System
open Plotly.NET

let (^) f x = f x
let fst (x, _) = x
let snd (_, y) = y

let inline table x = Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResourceFormatter.ToTabularDataResource x

#!markdown

## 1. Ознакомиться с поставленной задачей
_(готово)_

---

## 2. Сформировать исходное сообщение

#!fsharp

// let messageStr = "Проказин М.Р."
let messageStr = "Теремов Иван Алексеевич"

let message = Signal.encode messageStr

Signal.Formatting.printBitSeq message

#!markdown

## 3. Выполнить физическое кодирование сообщения

Выполнено кодирование следующими способами:
- NRZ
- Manchester
- AMI
- MLT-3
- PAM-5

#!fsharp

let physicalEncoders = [
    "NRZ", Signal.PhysicalEncoding.encodeNRZ
    "Manchester", Signal.PhysicalEncoding.encodeManchester
    "AMI", Signal.PhysicalEncoding.encodeAMI
    "MLT-3", Signal.PhysicalEncoding.encodeMLT3
    "PAM-5", Signal.PhysicalEncoding.encodePAM5
]

let signals =
    physicalEncoders
    |> List.map ^ fun (name, encoder) -> (name, encoder message)

let digitalRepr = 
    signals
    |> List.map ^ fun (name, signal) -> 
        {| code = name; signal = Signal.Formatting.bitsToString signal.levels |}

table digitalRepr

#!markdown

### Временные диаграммы сигналов

#!fsharp

let bitsToPlot = min 32 message.Length

let plots = 
    signals
    |> List.map ^ fun (name, signal) ->
        let oversamplingFactor = 40
        let oversampledSignal = Signal.oversample signal oversamplingFactor
        let segmentToPlot = List.takeWhile (fun (x, _) -> x < float (bitsToPlot)) oversampledSignal
        let x = List.map fst segmentToPlot
        let y = List.map snd segmentToPlot

        Chart.Line(x=x, y=y, Name=name)
        |> Chart.withXAxisStyle("bit_n")
        |> Chart.withYAxisStyle($"{name} potential")

plots
|> Chart.Grid(5, 1)
|> Chart.withSize(1200, 1300)

#!markdown

### Частотные характеристики

#!fsharp

signals
|> List.map (fun (name, signal) ->
    let freq = Signal.FrequencyAnalysis.analyze (int 1e9) signal
    {| Name = name
       LowerFrequencyBound  = Signal.Formatting.formatFreq freq.LowerFrequencyBound
       UpperFrequencyBound  = Signal.Formatting.formatFreq freq.UpperFrequencyBound 
       AverageFrequency     = Signal.Formatting.formatFreq freq.AverageFrequency
       SpectralWidth        = Signal.Formatting.formatFreq freq.SpectralWidth 
       EffectiveWidth       = Signal.Formatting.formatFreq freq.EffectiveWidth |}
)
|> table

#!markdown

**Вывод**

В результате проведённого анализа частотных характеристик различных методов физического кодирования было установлено, что наибольшую эффективность для передачи данного сообщения обеспечивают методы PAM-5 и MLT-3. Метод PAM-5 обладает минимальной шириной спектра сигнала, что позволяет существенно снизить требования к полосе пропускания канала и повысить скорость передачи данных. В то же время метод MLT-3 демонстрирует хорошее сочетание сравнительно узкой полосы спектра, простоты реализации и устойчивости к появлению постоянной составляющей в сигнале. Таким образом, именно PAM-5 и MLT-3 являются оптимальными с точки зрения эффективности использования полосы пропускания и практической реализации.

#!markdown

## 4. Выполнить логическое кодирование

#!markdown

### Избыточное кодирование 4B/5B

#!fsharp

let redundantMessage = Signal.LogicalEncoding.encode4b5b message

Signal.Formatting.printBitSeq redundantMessage

#!markdown

#### Физическое кодирование с избыточностью

#!fsharp

let effectivePhysicalEncoders = [
    "MLT-3", Signal.PhysicalEncoding.encodeMLT3
    "PAM-5", Signal.PhysicalEncoding.encodePAM5
]

let redundantSignals =
    effectivePhysicalEncoders
    |> List.map ^ fun (name, encoder) -> (name, encoder redundantMessage)

let redundantSignalPlots = 
    redundantSignals
    |> List.map ^ fun (name, signal) ->
        let oversamplingFactor = 40
        let oversampledSignal = Signal.oversample signal oversamplingFactor
        let segmentToPlot = List.takeWhile (fun (x, _) -> x < float (bitsToPlot)) oversampledSignal
        let x = List.map fst segmentToPlot
        let y = List.map snd segmentToPlot

        Chart.Line(x=x, y=y, Name=name)
        |> Chart.withXAxisStyle("bit_n")
        |> Chart.withYAxisStyle($"{name} potential")

redundantSignalPlots
|> Chart.Grid(2, 1)
|> Chart.withSize(1200, 500)

#!fsharp

redundantSignals
|> List.map (fun (name, signal) ->
    let freq = Signal.FrequencyAnalysis.analyze (int 1e9) signal
    {| Name = name
       LowerFrequencyBound  = Signal.Formatting.formatFreq freq.LowerFrequencyBound
       UpperFrequencyBound  = Signal.Formatting.formatFreq freq.UpperFrequencyBound 
       AverageFrequency     = Signal.Formatting.formatFreq freq.AverageFrequency
       SpectralWidth        = Signal.Formatting.formatFreq freq.SpectralWidth 
       EffectiveWidth       = Signal.Formatting.formatFreq freq.EffectiveWidth |}
)
|> table

#!markdown

**TODO** Выбрать наилучший способ физического кодирования для передачи
нового избыточного сообщения и обосновать этот выбор.

#!markdown

### Скремблирование исходного сообщения

#!markdown

**TODO** Выбрать оптимальный полином для скремблирования

#!fsharp

let scrambledMessage = Signal.LogicalEncoding.scrambleI35 message

Signal.Formatting.printBitSeq scrambledMessage

#!fsharp

let scrambledSignals =
    effectivePhysicalEncoders
    |> List.map ^ fun (name, encoder) -> (name, encoder scrambledMessage)

let scrambledSignalPlots = 
    redundantSignals
    |> List.map ^ fun (name, signal) ->
        let oversamplingFactor = 40
        let oversampledSignal = Signal.oversample signal oversamplingFactor
        let segmentToPlot = List.takeWhile (fun (x, _) -> x < float (bitsToPlot)) oversampledSignal
        let x = List.map fst segmentToPlot
        let y = List.map snd segmentToPlot

        Chart.Line(x=x, y=y, Name=name)
        |> Chart.withXAxisStyle("bit_n")
        |> Chart.withYAxisStyle($"{name} potential")

scrambledSignalPlots
|> Chart.Grid(2, 1)
|> Chart.withSize(1200, 500)
