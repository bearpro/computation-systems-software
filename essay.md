# Языки и системы программирования 

_**Содержание темы**: Языки программирования. Процедурные языки программирования, функциональные языки программирования, логическое программирование, объектно-ориентированные языки программирования. Распределенное программирование. Процессы и их синхронизация. Семафоры, мониторы Хоара._

Какие темы хочется раскрыть:

- Введение
  - Язык программирования - определение
  - Краткая история языков программирования
  - Классификация языков программированиях
  - Цели языков программирования
- Основная часть
  - Теоретическая основа языков программирования
    - Модели вычислений
    - Теория формальных языков
    - Грамматические и синтаксические анализаторы
    - Управление памятью
  - Популярные языки программирования
  - Некоторые особенные языки программирования
    - Промежуточные языки (байткод IL, LLVM, Python)
    - Языки для специфических сред и задач (шейдеры, CUDA, MPI)
  - Концепции за рамками традиционной классификации
    - Современные системы типов
    - Borrow checking
    - Формальная верификация
    - Корутины/синтаксис асинхронных вычислений
  - Современные особенности инфраструктуры программирования
    - Language Server Protocol
    - Системы сборки
    - Управление зависимостями
  - Особенности связанные с LLM
- Заключение
  - Перспективы языков программирования
  - Что не было рассмотрено
    - Специфические языки и расширения для фронтенд разработки

Структура:


1. Введение  
  1.1. Актуальность и цели  
  1.2. Обзор классификации и исторический контекст  

2. Теоретическая основа  
   2.1. Формальные грамматики и синтаксический анализ  
   2.2. Модели вычислений (Turing, λ-исчисление, π-исчисление)  
   2.3. Типизация и управление памятью  

3. Основные парадигмы  
   3.1. Процедурные и императивные языки  
   3.2. Функциональные языки  
   3.3. Логические языки  
   3.4. Объектно-ориентированные языки  

4. Параллелизм и распределённость  
   4.1. Потоки и процессы  
   4.2. Синхронизация (семафоры, мониторы, каналы)  
   4.3. Средства языка и библиотеки (MPI, OpenMP, CUDA, async/await)  

5. Современные расширения и новые парадигмы  
   5.1. Системы типов: обобщения, borrow checking  
   5.2. Формальная верификация, SMT-солверы  
   5.3. Корутины и асинхронность  

6. Инфраструктура и экосистема  
   6.1. Компиляторы, интерпретаторы и байткод  
   6.2. Системы сборки и менеджеры пакетов  
   6.3. Языковые серверы и инструменты разработки  
   6.4. Интеграция с ИИ-инструментами и LLM  

7. Сравнительный анализ и оценка  
   7.1. Критерии: производительность, безопасность, масштабируемость  
   7.2. Таблицы и диаграммы сравнений  

8. Заключение  
   8.1. Основные выводы  
   8.2. Ограничения исследования  
   8.3. Перспективы развития  

---

### 1. Введение

**1.1. Актуальность и цели**

* Языки программирования — ключевой инструмент для создания программного обеспечения всех типов вычислительных систем.
* Эволюция языков отражает изменения в требованиях к программируемым системам (надёжность, масштабируемость, безопасность).
* Цель реферата: систематизировать основные парадигмы, теоретические основы и современные тенденции развития языков программирования, а также рассмотреть их влияние на развитие вычислительных систем.

**1.2. Обзор классификации и исторический контекст**

* Краткая история развития языков: от ассемблеров к высокоуровневым языкам, затем к языкам специфических парадигм.
* Основные этапы: процедурное, объектно-ориентированное, функциональное, логическое программирование, языки для параллельных и распределённых систем.
* Классификация языков: по парадигме, уровню абстракции, способу реализации (компилируемые/интерпретируемые).

---

### 2. Теоретическая основа

**2.1. Формальные грамматики и синтаксический анализ**

* Языки программирования описываются формальными грамматиками (Бэкуса–Наура, регулярные, контекстно-свободные).
* Синтаксические анализаторы (парсеры) — ключевой компонент компиляторов и интерпретаторов.
* Анализ лексики, построение деревьев разбора, обработка ошибок синтаксиса.

**2.2. Модели вычислений**

* Машина Тьюринга, λ-исчисление, π-исчисление — абстрактные модели, описывающие вычислимость.
* Влияние моделей на формирование языков: например, λ-исчисление как основа функциональных языков, π-исчисление — распределённые процессы.
* Ограничения моделей: доказательство неразрешимости, влияние на проектирование языков.

**2.3. Типизация и управление памятью**

* Системы типов: статическая и динамическая типизация, обобщения, системы с выводом типов.
* Безопасность типов как способ предотвращения ошибок времени исполнения.
* Механизмы управления памятью: автоматическое (GC), ручное, уникальные подходы (borrow checking в Rust).
* Влияние на производительность и надёжность программ.

---

### 3. Основные парадигмы

**3.1. Процедурные и императивные языки**

* Базовая идея: программа как последовательность команд, изменяющих состояние памяти.
* Примеры: C, Pascal, Fortran.
* Простота освоения, прозрачность исполнения, удобство низкоуровневого программирования.

**3.2. Функциональные языки**

* Принцип: вычисления как применение функций, отсутствие побочных эффектов.
* Примеры: Haskell, OCaml, F#, Erlang.
* Параллелизм, лаконичность, простота формальной верификации, проблемы с производительностью и интеграцией с реальным миром.

**3.3. Логические языки**

* Описание задач в виде логических соотношений, решение — процесс поиска доказательств.
* Пример: Prolog.
* Применение: экспертные системы, обработка знаний.

**3.4. Объектно-ориентированные языки**

* Основные понятия: объекты, классы, наследование, инкапсуляция, полиморфизм.
* Примеры: C++, Java, C#, Python (много парадигм).
* Удобство моделирования сложных систем, расширяемость, повторное использование кода.

---

### 4. Параллелизм и распределённость

**4.1. Потоки и процессы**

* Внутриязыковые средства для создания и управления потоками и процессами.
* Примеры: std::thread (C++), Thread (Java), goroutines (Go), async/await (Python, C#).

**4.2. Синхронизация**

* Механизмы предотвращения гонок и неконсистентности: семафоры, мьютексы, мониторы (Хоара), каналы передачи сообщений.
* Языковые конструкции и стандартные библиотеки синхронизации.

**4.3. Средства языка и библиотеки**

* Языки и библиотеки для высокопроизводительных вычислений: MPI (Message Passing Interface), OpenMP (директивы параллелизма для C/C++/Fortran), CUDA (вычисления на GPU), современные async/await и reactive-подходы.
* Поддержка распределённых вычислений на уровне языка (например, Erlang, Elixir, Rust — actor-модели).

---

### 5. Современные расширения и новые парадигмы

**5.1. Системы типов: обобщения, borrow checking**

* Расширенные системы типов (дженерики, типы-высшего-порядка, dependent types).
* Механизм borrow checking (Rust): контроль владения памятью без сборщика мусора.
* Безопасность и отказоустойчивость программ.

**5.2. Формальная верификация, SMT-солверы**

* Методы доказательства корректности программ: Hoare logic, формальные спецификации, инструменты верификации (Coq, Z3).
* Автоматизированные доказательства свойств программ.

**5.3. Корутины и асинхронность**

* Механизмы кооперативной многозадачности, сопрограмм и асинхронного исполнения (корутины, async/await).
* Современные языковые расширения для обработки конкурентности без гонок.

---

### 6. Инфраструктура и экосистема

**6.1. Компиляторы, интерпретаторы и байткод**

* Принципы компиляции и интерпретации, промежуточные представления (IL/.NET, JVM/Java, LLVM, Python bytecode).
* Влияние выбора на производительность и переносимость программ.

**6.2. Системы сборки и менеджеры пакетов**

* Организация крупных проектов: make, CMake, Gradle, Maven, Cargo, npm.
* Менеджеры пакетов: автоматизация установки и обновления зависимостей.

**6.3. Языковые серверы и инструменты разработки**

* Language Server Protocol (LSP): стандартизация подсветки, автодополнения, рефакторинга для IDE.
* Современные инструменты анализа и повышения качества кода.

**6.4. Интеграция с ИИ-инструментами и LLM**

* Использование LLM для генерации и анализа кода, автокомплит, code review, автоматизация рутинных задач.
* Перспективы появления языков и фреймворков, "нативно дружелюбных" к ИИ.

---

### 7. Сравнительный анализ и оценка

**7.1. Критерии сравнения**

* Производительность (время выполнения, масштабируемость).
* Безопасность (контроль типов, отсутствие уязвимостей).
* Масштабируемость (удобство поддержки крупных проектов, поддержка модульности).
* Порог входа, развитость экосистемы, поддержка современных фич.

**7.2. Таблицы и диаграммы сравнений**

* Сводные таблицы сравнительных характеристик языков, парадигм, инфраструктурных решений.

---

### 8. Заключение

**8.1. Основные выводы**

* Современные языки и системы программирования являются фундаментом эволюции вычислительных систем, обеспечивая гибкость, безопасность и производительность.
* Эволюция языков продолжается, формируются новые парадигмы и инструменты под запросы индустрии и науки.

**8.2. Ограничения исследования**

* Объём работы не позволяет рассмотреть все языки и технологии (например, языки для web/front-end, DSL для узких областей).

**8.3. Перспективы развития**

* Дальнейшее развитие параллельных и распределённых языков, интеграция с ИИ-инструментами, формализация и автоматизация разработки ПО.
